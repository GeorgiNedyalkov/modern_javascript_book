// // Custom errors, extenting Error

// // When we develop something, we often need our own error classes to reflect specifi things
// // that may go wrong in our tasks.

// // For errors in network operations we may need HttpError, for database operations DbError, 
// // for searching operations NotFoundError and so on

// // Our errors should support basic error properties like message, name, and, preferably, stack.
// // They may also have properties of their own, e.g. HttpError objects may have a statusCode property
// // with a value like 404 or 403 or 500

// // JS allows to use throw with any argument, so technically our custom error classes don't need to 
// // inherit from Error. It's better to inherit from it, in any case, because it becomes possbile
// // to use obj instanceof Error to identify error objects. So it's better to inherit from it.

// // Extending Error

// class ValidationError extends Error {
//     constructor(message) {
//         super(message); // (1)
//         this.name = "ValidationError"; // (2)
//     }
// }

// function test() {
//     throw new ValidationError("Whoops!");
// }

// try {
//     test();
// } catch(err) {
//     console.log(err.message);
//     console.log(err.name);
//     console.log(err.stack);
// }

// // On line (1) we call the parent constructor which sets the message property
// // The parent constructor sets the name property to "Error", so in the line (2) we reset it to the 
// // right value

// // Let's try to use it in readUser(json)

// function readUser(json) {
//     let user = JSON.parse(json);

//     if (!user.age) {
//         throw new ValidationError("No field: age");
//     }
//     if (!user.name) {
//         throw new ValidationError("No field: name");
//     }

//     return user;
// }

// // Working example with try...catch

// try {
//     let user = readUser('{ "age": 25 }');
// } catch (err) {
//     if (err instanceof ValidationError) {
//         console.log("Invalid data: " + err.message); // Invalid data: No field: name
//     } else if (err instanceof SyntaxError) {         // (*)
//         console.log("JSON Syntax Error: " + err.message);
//     } else {
//         throw err; // unknown error, rethrow it (**)
//     }
// }

// // Line (*) checks for the specific error type with instanceof
// // We can also do the same with the name (err.name == "SyntaxError") 

// // The instanceof version is much better, because in the future we are going to extend ValidationError
// // make subtypes of it, like PropertyRequiredError. And instanceof check will continue to work for new
// // inheriting classes. So that's future proof

// // Further inheritance

// // The ValidationError class is very generic. Many things may go wrong. The property may be absent 
// // or it may be in a wrong format (like a string value for age instead of a number)
// // Let's make a more concrete class PropertyRequiredError, exactly for absent properties.
// // It will carry additional information about the property that's missing

// class PropertyRequiredError extends ValidationError {
//     constructor(property) {
//         super("No property" + property);
//         this.name = "PropertyRequiredError",
//         this.property = property;
//     }
// }

// try {
//   let user = readUser('{ "age": 25 }');
// } catch (err) {
//   if (err instanceof ValidationError) {
//     console.log("Invalid data: " + err.message); // Invalid data: No property: name
//     console.log(err.name); // PropertyRequiredError
//     console.log(err.property); // name
//   } else if (err instanceof SyntaxError) {
//     console.log("JSON Syntax Error: " + err.message);
//   } else {
//     throw err; // unknown error, rethrow it
//   }
// }

// // The new class PropertyRequiredError is easy to use: we only need to pass the property name:
// // new PropertyRequiredError(property). The human-readable message is generated by the constructor.

// // Let's make basic error class that assigns this.name = this.costructor.name

// class MyError extends Error {
//     constructor(message) {
//         this.name = this.constructor.name;
//     }
// }

// // class ValidationError extends MyError { }

// console.log( new PropertyRequiredError("field").name);

// // Wrapping exceptions

// // In the future there may be more errors as the funciton readUser becomes bigger.

// // The code should be able to handle these errors. 

// // The technique is called wrapping exceptions

class ReadError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
        this.name = 'ReadError';
    }
}

class ValidationError extends Error { /* ... */ }
class PropertyRequiredError extends ValidationError { /* ... */ }

function validateUser(user) {
    if (!user.name) {
        throw new PropertyRequiredError("age");
    }
    if (!user.age) {
        throw new PropertyRequiredError("name");
    }
}

function readUser(json) {
    let user;

    try {
        user = JSON.parse(json);
    } catch(err) {
       if (err instanceof SyntaxError) {
        throw new ReadError("Syntax Error", err);
       } else {
        throw err;
       } 
    }

    try {
        validateUser(user);
    } catch(err) {
        if (err instanceof ValidationError) {
            throw new ReadError("Validation Error", err);
        } else {
            throw err;
        }
    }
}

try {
    readUser('{bad json}');
} catch(e) {
    if (e instanceof ReadError) {
        console.log(e);
        // Original error: SyntaxError: Unexpected token b in JSON at position 1
        console.log("Original error" + e.cause);
    } else {
        throw e;
    }
} 

/*
In the code above, readUser works exactly as described – catches syntax and validation errors and throws ReadError errors 
instead (unknown errors are rethrown as usual).

So the outer code checks instanceof ReadError and that’s it. No need to list all possible error types.

The approach is called “wrapping exceptions”, because we take “low level” exceptions and “wrap” them into ReadError that is more abstract. 
It is widely used in object-oriented programming.

Summary
We can inherit from Error and other built-in error classes normally. 
We just need to take care of the name property and don’t forget to call super.
We can use instanceof to check for particular errors. It also works with inheritance. 
But sometimes we have an error object coming from a 3rd-party library and there’s no easy way to get its class. 
Then name property can be used for such checks.
Wrapping exceptions is a widespread technique: a function handles low-level exceptions and creates higher-level errors 
instead of various low-level ones. Low-level exceptions sometimes become properties of that object
like err.cause in the examples above, 
but that’s not strictly required.
*/